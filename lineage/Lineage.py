# author : shakthi visagan (shak360), adam weiner (adamcweiner)
# description: a file to hold the lineage class and population class

import sys
import math
import scipy.stats as sp
import matplotlib.pyplot as plt
import CellNode as c

class Lineage:
    def __init__(self):
        self.tree = list()
    
    def loadTree(self, csv_file):
        #TODO: write function to import a tree from external file
        pass
    
    def plotTree(self):
        '''plots a lineage tree based on list generated by a generate method or from the imported file'''
        lineage = self.tree # assign variable to tree list
        
        plt.figure(figsize=(48,24)) # set up figure for plotting, width and height in inches
        
        for cell in lineage:
            if cell.isRootParent():
                plt.plot(cell.startT, cell.plotVal, 'bo', markersize=10) # plot the root parent cell as a blue dot
            
            plt.plot([cell.startT,cell.endT],[cell.plotVal,cell.plotVal], 'k') # plot the cell lifetime
            
            if cell.fate:
                #TODO: replace the below if statement with the isUnfinished() method for clarity
                if not math.isnan(cell.endT): # check for nan when some cells don't get a chance to be assigned their fate, before the experiment ends
                    plt.plot([cell.endT,cell.endT],[cell.left.plotVal,cell.right.plotVal],'k') # plot a splitting line if the cell divides
            
            else:
                plt.plot(cell.endT, cell.plotVal, 'ro', markersize=10) # plot a red dot if the cell dies
        plt.plot()
        plt.show()
        #plt.savefig('foo.pdf')
        
        
def generatePopulationWithNum(numLineages, numCells, locBern, cGom, cScale):
    #TODO: go over how to organize and make various generate() methods
    ''' generates list given a maximum number of lineage trees, and parameters to describe the underlying distribution'''
    
    #create first lineage
    lineage0 = Lineage()
    
    # put first lineage in list
    population = [lineage0]
    
    while len(population) < numLineages:
        tempLineage = Lineage()
        tempLineage.tree = c.generateLineageWithNum(numCells, locBern, cGom, cScale)
        population.append(tempLineage)
    
    return(population)


def generatePopulationWithTime(numLineages, numCells, locBern, cGom, cScale):
    #TODO: go over how to organize and make various generate() methods
    ''' generates list given an experimental end time, and parameters to describe the underlying distribution'''   
    pass
        
class Population:
    def __init__(self):
        self.group = list()
        
    def loadPopulation(self, csv_file):
        #TODO: write function to import a population from external file
        pass
    
    def plotPopulation(self):
        '''plots a population of lineages'''
        #TODO
        pass
    
    def doublingTime(self):
        '''For a given population, calculates the population-level growth rate (i.e. doubling time)'''
        #TODO
        pass
    
    def bernoulliParameterEstimator(self):
        '''Estimates the Bernoulli parameter for a given population using MLE'''
        population = self.group # assign population to a variable
        mle_param_holder = [] # instantiates list to hold cell fates as 1s or 0s
        for lineage in population: # go through every lineage in the population
            for cell in lineage.tree: # go through ever cell in the lineage
                if not cell.isUnfinished(): # if the cell has lived a meaningful life and matters
                    mle_param_holder.append(cell.fate*1) # append 1 for dividing, and 0 for dying
                    
        return ( sum(mle_param_holder) / len(mle_param_holder) ) # add up all the 1s and divide by the total length (finding the average)