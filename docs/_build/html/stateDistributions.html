
<!DOCTYPE html>

<html lang="Python3">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>State Distributions - How to create &#8212; tHMM 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="state-distributions-how-to-create">
<h1><strong>State Distributions</strong> - How to create<a class="headerlink" href="#state-distributions-how-to-create" title="Permalink to this headline">¶</a></h1>
<p>The Emissions matrix is created using State Distribution
objects. A state can be defined as a particular condition the cell is in
(eg. Resistant vs Susceptible to a drug treatment), which is represented by it’s
distribution(s)/parameter(s). Just as a state can be defined in whatever way
one desires, so can the distributions - typically as some type of
physical observation/phenotype.</p>
<p>The following codes present two examples of how to create StateDistribution.
The first example shows that a state of a cell, can be determined by two phenotypes,
that are cell fate and cell lifetime. Cell fate, which is whether a cell dies or gets to divide,
is representated by a Bernoulli distribution which is defined by one parameter, shown as bern_p.
Cell lifetime, which is the intermitotic time for each cell, is represented by a Gamma distribution
which is defined by two parameters, shown as <cite>gamma_a</cite> and <cite>gamma_scale</cite>.
In this case, they are independent of each other -- but that may not always be the case.</p>
<p>The second example shows that a state of a cell can be determined only using cell size.
We used a Normal distribution to model the cell size, which has two parameters;
mean and standard deviation, shown as <cite>norm_loc</cite> and <cite>norm_scale</cite>, respectively. Please note that
in this case we are assuming all cells should be accounted for, i.e., we have no censorship.</p>
<p>Necessary components to create StateDistribution class compatible with tHMM are listed bellow:</p>
<section id="the-initialization-function">
<h2>1. The initialization function<a class="headerlink" href="#the-initialization-function" title="Permalink to this headline">¶</a></h2>
<p>This should take in all defining
parameters for all distributions being used. For the first example, Bernoulli and Gamma, it would be
<cite>bern_p</cite>, <cite>gamma_a</cite>, and <cite>gamma_scale</cite>, and for the sencond example, the normal distribution,
this would be <cite>norm_loc</cite>, and <cite>norm_scale</cite>.
These are assigned as instances of the class object. One can assert that the given values
actually make sense for the distribution. For example, a normal
distribution cannot have a negative or zero standard deviation.</p>
</section>
<section id="random-variable-generator-function">
<h2>2. Random variable generator function<a class="headerlink" href="#random-variable-generator-function" title="Permalink to this headline">¶</a></h2>
<p>To create synthetic data, we need to generate random variables of the defined distributions as cell observations.
We do that using the rvs (random variables) function, which actually uses the built-in scipy function rvs.
It takes in size, which represents the number of cells in
the lineage, and assigns each one a random variable from the
characteristic distributions of that state. There is one per
distribution. The time_censor variable exists due to the time based
nature of the gamma distribution. Such a variable is unnecessary in the
normal example, but may be needed depending on the type of censoring
done.
While creatig our synthetic data, at first, we assume all cells are observed and there is no censored cells.
The variables <cite>gamma_obs_censor</cite> and <cite>norm_obs_censor</cite> are created and set to 1 for each cell to represent that.
We do the censoring later.
The rvs function returns the observed phenotypes as a tuple of lists.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Bernoulli/Gamma</span>
<span class="k">def</span> <span class="nf">rvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; User-defined way of calculating a random variable given the parameters of the state stored in their StateType object. &quot;&quot;&quot;</span>

    <span class="n">bern_obs</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">bernoulli</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>  <span class="c1"># bernoulli observations</span>
    <span class="n">gamma_obs</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">gamma</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">size</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>  <span class="c1"># gamma observations</span>
    <span class="n">gamma_obs_censor</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">size</span>  <span class="c1"># 1 if observed</span>

    <span class="c1"># These tuples of observations will go into the cells in the lineage tree.</span>
    <span class="k">return</span> <span class="n">bern_obs</span><span class="p">,</span> <span class="n">gamma_obs</span><span class="p">,</span> <span class="n">gamma_obs_censor</span>
</pre></div>
</div>
</section>
<section id="pdf">
<h2>3. PDF<a class="headerlink" href="#pdf" title="Permalink to this headline">¶</a></h2>
<p>The third required function is the probability distribution function (pdf).
For univariate and independent multivariate distributions, it is fairly
simple and can just use the already implemented pdf functions in scipy.
For more complex multivariate distributions, the pdf might be more
complicated and require a custom function. It is to calculate the likelihood of the observations.</p>
<p>In the Bernoulli/Gamma example, we assume the two phenotypes are independent
and we add their Log-lilelihood to find the total log-likelihood,
which is equivalent to multiplying the likelihoods.</p>
<p>In this function, we consider the censorship of the observations,
based on the integer value we assigned to them to show whether they are censored or not.
The fully observed cells are fed to <cite>logpdf</cite> to calculate the likelihood,
and those cells that have missing information are fed to <cite>logsf</cite>.
Those cells that died are then removed in the first example that cell's fate matters.</p>
</section>
<section id="the-estimator">
<h2>4. The estimator<a class="headerlink" href="#the-estimator" title="Permalink to this headline">¶</a></h2>
<p>The <cite>estimator</cite> method provides estimation of distribution parameters given the observations.
The user must define their own estimator function.
Typically this would just be the maximum likelihood estimate,
but in our fisr example, due the the incorporation of the gammas term
and that we have censorship, it is slightly more complicated.
One must find the MLE by taking the product of the pdf over all
obervations (the likelihood), then taking the log, then the derivative
and setting equal to zero to find the optimal value. For the Bernoulli,
for example, the likelihood is the product from i=1 to n (where there
are n observations) of p^x_i * (1-p)^1-x_i.</p>
<p>For the Bernoulli it becomes the product from i=1 to n of (p^x_i *
(1-p)<sup>1-x_i)</sup>z_i. The MLE is then calculated as normal. Once
this modified MLE is found for each parameter, the estimator function
must simply calculate and return it given the observations and gammas.
The Gamma estimator function takes in the observations, and uses the
minimize function of the scipy.optimize to find the parameters and
the function is located in the lineage/states/stateCommon.py</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Bernoulli/Gamma</span>
<span class="k">def</span> <span class="nf">estimator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">gammas</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; User-defined way of estimating the parameters given a list of the tuples of observations from a group of cells. &quot;&quot;&quot;</span>

    <span class="c1"># getting the observations as individual lists</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">bern_obs</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
    <span class="n">γ_obs</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="n">gamma_obs_censor</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>

    <span class="n">b_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">bern_obs</span><span class="p">)</span>
    <span class="c1"># Both unoberved and dead cells should be removed from gamma</span>
    <span class="n">g_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">γ_obs</span><span class="p">),</span> <span class="n">bern_obs</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">g_mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;All the cells are eliminated from the Gamma estimator.&quot;</span>

    <span class="c1"># Handle an empty state</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gammas</span><span class="p">[</span><span class="n">b_mask</span><span class="p">])</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">bern_obs</span><span class="p">[</span><span class="n">b_mask</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">bern_obs</span><span class="p">[</span><span class="n">b_mask</span><span class="p">],</span> <span class="n">weights</span><span class="o">=</span><span class="n">gammas</span><span class="p">[</span><span class="n">b_mask</span><span class="p">])</span>

    <span class="c1"># Don&#39;t allow Bernoulli to hit extremes</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.00001</span><span class="p">,</span> <span class="mf">0.99999</span><span class="p">)</span> <span class="c1"># bernoulli parameter</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">gamma_estimator</span><span class="p">(</span><span class="n">γ_obs</span><span class="p">[</span><span class="n">g_mask</span><span class="p">],</span> <span class="n">gamma_obs_censor</span><span class="p">[</span><span class="n">g_mask</span><span class="p">],</span> <span class="n">gammas</span><span class="p">[</span><span class="n">g_mask</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">])</span> <span class="c1"># gamma shape and scale</span>
</pre></div>
</div>
</section>
<section id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>Now that we have a functioning Gaussian StateDistribution, let’s try it
with the overall model. As in the overview, we first define our initial probability vector and
the state transition probability matrices.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lineage.LineageTree</span> <span class="kn">import</span> <span class="n">LineageTree</span>

<span class="n">pi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">],</span>
              <span class="p">[</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;float&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Creating the Emissions for two states:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># E: states are defined as StateDistribution objects</span>

<span class="c1"># Normal distribution state 0 parameters &quot;Basal&quot;</span>
<span class="n">norm_loc0</span> <span class="o">=</span> <span class="mi">14</span>
<span class="n">norm_scale0</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># Normal distribution state 1 parameters &quot;Luminal&quot;</span>
<span class="n">norm_loc1</span> <span class="o">=</span> <span class="mi">19</span>
<span class="n">norm_scale1</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">state_obj0</span> <span class="o">=</span> <span class="n">StateDistribution</span><span class="p">(</span><span class="n">norm_loc0</span><span class="p">,</span> <span class="n">norm_scale0</span><span class="p">)</span>
<span class="n">state_obj1</span> <span class="o">=</span> <span class="n">StateDistribution</span><span class="p">(</span><span class="n">norm_loc1</span><span class="p">,</span> <span class="n">norm_scale1</span><span class="p">)</span>

<span class="n">E</span> <span class="o">=</span> <span class="p">[</span><span class="n">state_obj0</span><span class="p">,</span> <span class="n">state_obj1</span><span class="p">]</span>
</pre></div>
</div>
<p>Creating the lineage tree:</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lineage1</span> <span class="o">=</span> <span class="n">LineageTree</span><span class="o">.</span><span class="n">init_from_parameters</span><span class="p">(</span><span class="n">pi</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">desired_num_cells</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">5</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># These are the minimal arguments required to instantiate lineages</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lineage1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>Below is the analysis for a single lineage. Note that the state objects
are merely switched. However, the model fairly accurately predicts the
transition matrix and state parameters.</p>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">lineage.Analyze</span> <span class="kn">import</span> <span class="n">Analyze</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">[</span><span class="n">lineage1</span><span class="p">]</span> <span class="c1"># population just contains one lineage</span>
<span class="n">tHMMobj</span><span class="p">,</span> <span class="n">pred_states_by_lineage</span><span class="p">,</span> <span class="n">LL</span> <span class="o">=</span> <span class="n">Analyze</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># find two states</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">tHMMobj</span><span class="o">.</span><span class="n">estimate</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">tHMMobj</span><span class="o">.</span><span class="n">estimate</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">lineage1</span><span class="o">.</span><span class="n">num_states</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;State </span><span class="si">{}</span><span class="s2">:&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">state</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;                    estimated state:&quot;</span><span class="p">,</span> <span class="n">tHMMobj</span><span class="o">.</span><span class="n">estimate</span><span class="o">.</span><span class="n">E</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;original parameters given for state:&quot;</span><span class="p">,</span> <span class="n">E</span><span class="p">[</span><span class="n">state</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">tHMM</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="Installation.html">Installation</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="system-reqs.html">System Requirements</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="demo.html">Demo and Instructions</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2022, Farnaz Mohammadi, JC Lagarde, Aaron S Meyer.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 4.5.0</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="_sources/stateDistributions.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>